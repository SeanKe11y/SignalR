/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./NotificationComponent/index.ts":
/*!****************************************!*\
  !*** ./NotificationComponent/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NotificationComponent = void 0;\nvar signalR = __webpack_require__(/*! @microsoft/signalr */ \"./node_modules/@microsoft/signalr/dist/esm/index.js\");\nvar NotificationComponent = /** @class */function () {\n  /**\r\n   * Empty constructor.\r\n   */\n  function NotificationComponent() {}\n  /**\r\n   * Used to initialize the control instance. Controls can kick off remote server calls and other initialization actions here.\r\n   * Data-set values are not initialized here, use updateView.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to property names defined in the manifest, as well as utility functions.\r\n   * @param notifyOutputChanged A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\r\n   * @param state A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\r\n   * @param container If a control is marked control-type='standard', it will receive an empty div element within which it can render its content.\r\n   */\n  NotificationComponent.prototype.init = function (context, notifyOutputChanged, state, container) {\n    var _this = this;\n    // Add control initialization code\n    this._context = context;\n    this._notifyOutputChanged = notifyOutputChanged;\n    this._signalRApi = context.parameters.signalRHubConnectionUrl.raw ? context.parameters.signalRHubConnectionUrl.raw : \"\";\n    this._connection = new signalR.HubConnectionBuilder().withUrl(this._signalRApi).configureLogging(signalR.LogLevel.Information).withAutomaticReconnect().build();\n    //configure the event when a new message arrives\n    this._connection.on(\"newMessage\", function (message) {\n      _this._message = message;\n      _this._notifyOutputChanged();\n    });\n    //connect\n    this._connection.start().catch(function (err) {\n      console.log(err);\n      _this._connection.stop();\n    });\n  };\n  /**\r\n   * Called when any value in the property bag has changed. This includes field values, data-sets, global values such as container height and width, offline status, control metadata values such as label, visible, etc.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to names defined in the manifest, as well as utility functions\r\n   */\n  NotificationComponent.prototype.updateView = function (context) {\n    //When the messageData is updated this code will run and we send the message to signalR\n    this._context = context;\n    //check for updateProperties \t\n    if (context.updatedProperties != null && context.updatedProperties.length != 0) {\n      if (context.updatedProperties.indexOf(\"messageData\") > -1) {\n        var messageData = JSON.parse(this._context.parameters.messageData.raw != null ? this._context.parameters.messageData.raw : \"\");\n        if (messageData.text) {\n          this.httpCall(messageData, function (res) {\n            console.log(res);\n          });\n        }\n      }\n    }\n  };\n  NotificationComponent.prototype.httpCall = function (data, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"post\", this._signalRApi + \"/messages\", true);\n    if (data != null) {\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(JSON.stringify(data));\n    } else xhr.send();\n  };\n  /**\r\n   * It is called by the framework prior to a control receiving new data.\r\n   * @returns an object based on nomenclature defined in manifest, expecting object[s] for property marked as “bound” or “output”\r\n   */\n  NotificationComponent.prototype.getOutputs = function () {\n    //This code will run when we call notifyOutputChanged when we receive a new message\n    //here is where the message gets exposed to outside\n    var output = {\n      messageReceivedText: this._message.text,\n      messageReceivedTime: this._message.time,\n      messageReceivedSender: this._message.sender,\n      messageReceivedImage: this._message.image\n    };\n    return output;\n  };\n  /**\r\n   * Called when the control is to be removed from the DOM tree. Controls should use this call for cleanup.\r\n   * i.e. cancelling any pending remote calls, removing listeners, etc.\r\n   */\n  NotificationComponent.prototype.destroy = function () {\n    // Add code to cleanup control if necessary\n    if (this._connection) {\n      this._connection.stop();\n    }\n  };\n  return NotificationComponent;\n}();\nexports.NotificationComponent = NotificationComponent;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./NotificationComponent/index.ts?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/AbortController.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/AbortController.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ AbortController)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\n// it's a very new API right now.\n// Not exported from index.\n/** @private */\nclass AbortController {\n  constructor() {\n    this._isAborted = false;\n    this.onabort = null;\n  }\n  abort() {\n    if (!this._isAborted) {\n      this._isAborted = true;\n      if (this.onabort) {\n        this.onabort();\n      }\n    }\n  }\n  get signal() {\n    return this;\n  }\n  get aborted() {\n    return this._isAborted;\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/AbortController.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenHttpClient: () => (/* binding */ AccessTokenHttpClient)\n/* harmony export */ });\n/* harmony import */ var _HeaderNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HeaderNames */ \"./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/HttpClient.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n/** @private */\nclass AccessTokenHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpClient {\n  constructor(innerClient, accessTokenFactory) {\n    super();\n    this._innerClient = innerClient;\n    this._accessTokenFactory = accessTokenFactory;\n  }\n  send(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var allowRetry = true;\n      if (_this._accessTokenFactory && (!_this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0)) {\n        // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n        allowRetry = false;\n        _this._accessToken = yield _this._accessTokenFactory();\n      }\n      _this._setAuthorizationHeader(request);\n      var response = yield _this._innerClient.send(request);\n      if (allowRetry && response.statusCode === 401 && _this._accessTokenFactory) {\n        _this._accessToken = yield _this._accessTokenFactory();\n        _this._setAuthorizationHeader(request);\n        return yield _this._innerClient.send(request);\n      }\n      return response;\n    })();\n  }\n  _setAuthorizationHeader(request) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n    if (this._accessToken) {\n      request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_1__.HeaderNames.Authorization] = \"Bearer \".concat(this._accessToken);\n    }\n    // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n    else if (this._accessTokenFactory) {\n      if (request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_1__.HeaderNames.Authorization]) {\n        delete request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_1__.HeaderNames.Authorization];\n      }\n    }\n  }\n  getCookieString(url) {\n    return this._innerClient.getCookieString(url);\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultHttpClient: () => (/* binding */ DefaultHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _FetchHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FetchHttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/HttpClient.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n/* harmony import */ var _XhrHttpClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./XhrHttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\nclass DefaultHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpClient {\n  /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n  constructor(logger) {\n    super();\n    if (typeof fetch !== \"undefined\" || _Utils__WEBPACK_IMPORTED_MODULE_1__.Platform.isNode) {\n      this._httpClient = new _FetchHttpClient__WEBPACK_IMPORTED_MODULE_2__.FetchHttpClient(logger);\n    } else if (typeof XMLHttpRequest !== \"undefined\") {\n      this._httpClient = new _XhrHttpClient__WEBPACK_IMPORTED_MODULE_3__.XhrHttpClient(logger);\n    } else {\n      throw new Error(\"No usable HttpClient found.\");\n    }\n  }\n  /** @inheritDoc */\n  send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_4__.AbortError());\n    }\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n    return this._httpClient.send(request);\n  }\n  getCookieString(url) {\n    return this._httpClient.getCookieString(url);\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// 0, 2, 10, 30 second delays before reconnect attempts.\nvar DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\n/** @private */\nclass DefaultReconnectPolicy {\n  constructor(retryDelays) {\n    this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\n  }\n  nextRetryDelayInMilliseconds(retryContext) {\n    return this._retryDelays[retryContext.previousRetryCount];\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/Errors.js":
/*!************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Errors.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateErrors: () => (/* binding */ AggregateErrors),\n/* harmony export */   DisabledTransportError: () => (/* binding */ DisabledTransportError),\n/* harmony export */   FailedToNegotiateWithServerError: () => (/* binding */ FailedToNegotiateWithServerError),\n/* harmony export */   FailedToStartTransportError: () => (/* binding */ FailedToStartTransportError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   UnsupportedTransportError: () => (/* binding */ UnsupportedTransportError)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Error thrown when an HTTP request fails. */\nclass HttpError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   * @param {number} statusCode The HTTP status code represented by this error.\r\n   */\n  constructor(errorMessage, statusCode) {\n    var trueProto = new.target.prototype;\n    super(\"\".concat(errorMessage, \": Status code '\").concat(statusCode, \"'\"));\n    this.statusCode = statusCode;\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when a timeout elapses. */\nclass TimeoutError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   */\n  constructor() {\n    var errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"A timeout occurred.\";\n    var trueProto = new.target.prototype;\n    super(errorMessage);\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when an action is aborted. */\nclass AbortError extends Error {\n  /** Constructs a new instance of {@link AbortError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   */\n  constructor() {\n    var errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"An abort occurred.\";\n    var trueProto = new.target.prototype;\n    super(errorMessage);\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when the selected transport is unsupported by the browser. */\n/** @private */\nclass UnsupportedTransportError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n   *\r\n   * @param {string} message A descriptive error message.\r\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n   */\n  constructor(message, transport) {\n    var trueProto = new.target.prototype;\n    super(message);\n    this.transport = transport;\n    this.errorType = 'UnsupportedTransportError';\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when the selected transport is disabled by the browser. */\n/** @private */\nclass DisabledTransportError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n   *\r\n   * @param {string} message A descriptive error message.\r\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n   */\n  constructor(message, transport) {\n    var trueProto = new.target.prototype;\n    super(message);\n    this.transport = transport;\n    this.errorType = 'DisabledTransportError';\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when the selected transport cannot be started. */\n/** @private */\nclass FailedToStartTransportError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n   *\r\n   * @param {string} message A descriptive error message.\r\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n   */\n  constructor(message, transport) {\n    var trueProto = new.target.prototype;\n    super(message);\n    this.transport = transport;\n    this.errorType = 'FailedToStartTransportError';\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when the negotiation with the server failed to complete. */\n/** @private */\nclass FailedToNegotiateWithServerError extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n   *\r\n   * @param {string} message A descriptive error message.\r\n   */\n  constructor(message) {\n    var trueProto = new.target.prototype;\n    super(message);\n    this.errorType = 'FailedToNegotiateWithServerError';\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n/** Error thrown when multiple errors have occurred. */\n/** @private */\nclass AggregateErrors extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n   *\r\n   * @param {string} message A descriptive error message.\r\n   * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n   */\n  constructor(message, innerErrors) {\n    var trueProto = new.target.prototype;\n    super(message);\n    this.innerErrors = innerErrors;\n    // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n    this.__proto__ = trueProto;\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/Errors.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchHttpClient: () => (/* binding */ FetchHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/HttpClient.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\nclass FetchHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc =  true ? require : 0;\n      // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      this._fetchType = requireFunc(\"node-fetch\");\n      // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)());\n    }\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var _requireFunc =  true ? require : 0;\n      // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n      this._abortControllerType = _requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n  send(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Check that abort was not signaled before calling send\n      if (request.abortSignal && request.abortSignal.aborted) {\n        throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError();\n      }\n      if (!request.method) {\n        throw new Error(\"No method defined.\");\n      }\n      if (!request.url) {\n        throw new Error(\"No url defined.\");\n      }\n      var abortController = new _this._abortControllerType();\n      var error;\n      // Hook our abortSignal into the abort controller\n      if (request.abortSignal) {\n        request.abortSignal.onabort = () => {\n          abortController.abort();\n          error = new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError();\n        };\n      }\n      // If a timeout has been passed in, setup a timeout to call abort\n      // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n      var timeoutId = null;\n      if (request.timeout) {\n        var msTimeout = request.timeout;\n        timeoutId = setTimeout(() => {\n          abortController.abort();\n          _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, \"Timeout from HTTP request.\");\n          error = new _Errors__WEBPACK_IMPORTED_MODULE_2__.TimeoutError();\n        }, msTimeout);\n      }\n      if (request.content === \"\") {\n        request.content = undefined;\n      }\n      if (request.content) {\n        // Explicitly setting the Content-Type header for React Native on Android platform.\n        request.headers = request.headers || {};\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isArrayBuffer)(request.content)) {\n          request.headers[\"Content-Type\"] = \"application/octet-stream\";\n        } else {\n          request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n        }\n      }\n      var response;\n      try {\n        response = yield _this._fetchType(request.url, {\n          body: request.content,\n          cache: \"no-cache\",\n          credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n          headers: _objectSpread({\n            \"X-Requested-With\": \"XMLHttpRequest\"\n          }, request.headers),\n          method: request.method,\n          mode: \"cors\",\n          redirect: \"follow\",\n          signal: abortController.signal\n        });\n      } catch (e) {\n        if (error) {\n          throw error;\n        }\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, \"Error from HTTP request. \".concat(e, \".\"));\n        throw e;\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n      }\n      if (!response.ok) {\n        var errorMessage = yield deserializeContent(response, \"text\");\n        throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpError(errorMessage || response.statusText, response.status);\n      }\n      var content = deserializeContent(response, request.responseType);\n      var payload = yield content;\n      return new _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpResponse(response.status, response.statusText, payload);\n    })();\n  }\n  getCookieString(url) {\n    var cookies = \"\";\n    if (_Utils__WEBPACK_IMPORTED_MODULE_1__.Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n    return cookies;\n  }\n}\nfunction deserializeContent(response, responseType) {\n  var content;\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n    case \"text\":\n      content = response.text();\n      break;\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(\"\".concat(responseType, \" is not supported.\"));\n    default:\n      content = response.text();\n      break;\n  }\n  return content;\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HandshakeProtocol: () => (/* binding */ HandshakeProtocol)\n/* harmony export */ });\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextMessageFormat */ \"./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n/** @private */\nclass HandshakeProtocol {\n  // Handshake request is always JSON\n  writeHandshakeRequest(handshakeRequest) {\n    return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.write(JSON.stringify(handshakeRequest));\n  }\n  parseHandshakeResponse(data) {\n    var messageData;\n    var remainingData;\n    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isArrayBuffer)(data)) {\n      // Format is binary but still need to read JSON text from handshake response\n      var binaryData = new Uint8Array(data);\n      var separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.RecordSeparatorCode);\n      if (separatorIndex === -1) {\n        throw new Error(\"Message is incomplete.\");\n      }\n      // content before separator is handshake response\n      // optional content after is additional messages\n      var responseLength = separatorIndex + 1;\n      messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\n      remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;\n    } else {\n      var textData = data;\n      var _separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.RecordSeparator);\n      if (_separatorIndex === -1) {\n        throw new Error(\"Message is incomplete.\");\n      }\n      // content before separator is handshake response\n      // optional content after is additional messages\n      var _responseLength = _separatorIndex + 1;\n      messageData = textData.substring(0, _responseLength);\n      remainingData = textData.length > _responseLength ? textData.substring(_responseLength) : null;\n    }\n    // At this point we should have just the single handshake message\n    var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.parse(messageData);\n    var response = JSON.parse(messages[0]);\n    if (response.type) {\n      throw new Error(\"Expected a handshake response from the server.\");\n    }\n    var responseMessage = response;\n    // multiple messages could have arrived with handshake\n    // return additional data to be parsed as usual, or null if all parsed\n    return [remainingData, responseMessage];\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeaderNames: () => (/* binding */ HeaderNames)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nclass HeaderNames {}\nHeaderNames.Authorization = \"Authorization\";\nHeaderNames.Cookie = \"Cookie\";\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HttpClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HttpClient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Represents an HTTP response. */\nclass HttpResponse {\n  constructor(statusCode, statusText, content) {\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n    this.content = content;\n  }\n}\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\nclass HttpClient {\n  get(url, options) {\n    return this.send(_objectSpread(_objectSpread({}, options), {}, {\n      method: \"GET\",\n      url\n    }));\n  }\n  post(url, options) {\n    return this.send(_objectSpread(_objectSpread({}, options), {}, {\n      method: \"POST\",\n      url\n    }));\n  }\n  delete(url, options) {\n    return this.send(_objectSpread(_objectSpread({}, options), {}, {\n      method: \"DELETE\",\n      url\n    }));\n  }\n  /** Gets all cookies that apply to the specified URL.\r\n   *\r\n   * @param url The URL that the cookies are valid for.\r\n   * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n   */\n  // @ts-ignore\n  getCookieString(url) {\n    return \"\";\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HttpClient.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js":
/*!********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpConnection: () => (/* binding */ HttpConnection),\n/* harmony export */   TransportSendQueue: () => (/* binding */ TransportSendQueue)\n/* harmony export */ });\n/* harmony import */ var _AccessTokenHttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AccessTokenHttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js\");\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultHttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _LongPollingTransport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LongPollingTransport */ \"./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js\");\n/* harmony import */ var _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ServerSentEventsTransport */ \"./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n/* harmony import */ var _WebSocketTransport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebSocketTransport */ \"./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\n\n\n\nvar MAX_REDIRECTS = 100;\n/** @private */\nclass HttpConnection {\n  constructor(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._stopPromiseResolver = () => {};\n    this.features = {};\n    this._negotiateVersion = 1;\n    _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isRequired(url, \"url\");\n    this._logger = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.createLogger)(options.logger);\n    this.baseUrl = this._resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n    options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\n    var webSocketModule = null;\n    var eventSourceModule = null;\n    if (_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode && \"function\" !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc =  true ? require : 0;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n    this._httpClient = new _AccessTokenHttpClient__WEBPACK_IMPORTED_MODULE_1__.AccessTokenHttpClient(options.httpClient || new _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__.DefaultHttpClient(this._logger), options.accessTokenFactory);\n    this._connectionState = \"Disconnected\" /* Disconnected */;\n    this._connectionStarted = false;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  start(transferFormat) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      transferFormat = transferFormat || _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat.Binary;\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat, \"transferFormat\");\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Starting connection with transfer format '\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat[transferFormat], \"'.\"));\n      if (_this._connectionState !== \"Disconnected\" /* Disconnected */) {\n        return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n      }\n      _this._connectionState = \"Connecting\" /* Connecting */;\n      _this._startInternalPromise = _this._startInternal(transferFormat);\n      yield _this._startInternalPromise;\n      // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\n      if (_this._connectionState === \"Disconnecting\" /* Disconnecting */) {\n        // stop() was called and transitioned the client into the Disconnecting state.\n        var message = \"Failed to start the HttpConnection before stop() was called.\";\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, message);\n        // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n        yield _this._stopPromise;\n        return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_5__.AbortError(message));\n      } else if (_this._connectionState !== \"Connected\" /* Connected */) {\n        // stop() was called and transitioned the client into the Disconnecting state.\n        var _message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, _message);\n        return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_5__.AbortError(_message));\n      }\n      _this._connectionStarted = true;\n    })();\n  }\n  send(data) {\n    if (this._connectionState !== \"Connected\" /* Connected */) {\n      return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n    }\n    if (!this._sendQueue) {\n      this._sendQueue = new TransportSendQueue(this.transport);\n    }\n    // Transport will not be null if state is connected\n    return this._sendQueue.send(data);\n  }\n  stop(error) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2._connectionState === \"Disconnected\" /* Disconnected */) {\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnected state.\"));\n        return Promise.resolve();\n      }\n      if (_this2._connectionState === \"Disconnecting\" /* Disconnecting */) {\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnecting state.\"));\n        return _this2._stopPromise;\n      }\n      _this2._connectionState = \"Disconnecting\" /* Disconnecting */;\n      _this2._stopPromise = new Promise(resolve => {\n        // Don't complete stop() until stopConnection() completes.\n        _this2._stopPromiseResolver = resolve;\n      });\n      // stopInternal should never throw so just observe it.\n      yield _this2._stopInternal(error);\n      yield _this2._stopPromise;\n    })();\n  }\n  _stopInternal(error) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Set error as soon as possible otherwise there is a race between\n      // the transport closing and providing an error and the error from a close message\n      // We would prefer the close message error.\n      _this3._stopError = error;\n      try {\n        yield _this3._startInternalPromise;\n      } catch (e) {\n        // This exception is returned to the user as a rejected Promise from the start method.\n      }\n      // The transport's onclose will trigger stopConnection which will run our onclose event.\n      // The transport should always be set if currently connected. If it wasn't set, it's likely because\n      // stop was called during start() and start() failed.\n      if (_this3.transport) {\n        try {\n          yield _this3.transport.stop();\n        } catch (e) {\n          _this3._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"HttpConnection.transport.stop() threw error '\".concat(e, \"'.\"));\n          _this3._stopConnection();\n        }\n        _this3.transport = undefined;\n      } else {\n        _this3._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n      }\n    })();\n  }\n  _startInternal(transferFormat) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Store the original base url and the access token factory since they may change\n      // as part of negotiating\n      var url = _this4.baseUrl;\n      _this4._accessTokenFactory = _this4._options.accessTokenFactory;\n      _this4._httpClient._accessTokenFactory = _this4._accessTokenFactory;\n      try {\n        if (_this4._options.skipNegotiation) {\n          if (_this4._options.transport === _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.WebSockets) {\n            // No need to add a connection ID in this case\n            _this4.transport = _this4._constructTransport(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.WebSockets);\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            yield _this4._startTransport(url, transferFormat);\n          } else {\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n          }\n        } else {\n          var negotiateResponse = null;\n          var redirects = 0;\n          var _loop = function* _loop() {\n            negotiateResponse = yield _this4._getNegotiationResponse(url);\n            // the user tries to stop the connection when it is being started\n            if (_this4._connectionState === \"Disconnecting\" /* Disconnecting */ || _this4._connectionState === \"Disconnected\" /* Disconnected */) {\n              throw new _Errors__WEBPACK_IMPORTED_MODULE_5__.AbortError(\"The connection was stopped during negotiation.\");\n            }\n            if (negotiateResponse.error) {\n              throw new Error(negotiateResponse.error);\n            }\n            if (negotiateResponse.ProtocolVersion) {\n              throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n            }\n            if (negotiateResponse.url) {\n              url = negotiateResponse.url;\n            }\n            if (negotiateResponse.accessToken) {\n              // Replace the current access token factory with one that uses\n              // the returned access token\n              var accessToken = negotiateResponse.accessToken;\n              _this4._accessTokenFactory = () => accessToken;\n              // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\n              _this4._httpClient._accessToken = accessToken;\n              _this4._httpClient._accessTokenFactory = undefined;\n            }\n            redirects++;\n          };\n          do {\n            yield* _loop();\n          } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\n          if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n            throw new Error(\"Negotiate redirection limit exceeded.\");\n          }\n          yield _this4._createTransport(url, _this4._options.transport, negotiateResponse, transferFormat);\n        }\n        if (_this4.transport instanceof _LongPollingTransport__WEBPACK_IMPORTED_MODULE_6__.LongPollingTransport) {\n          _this4.features.inherentKeepAlive = true;\n        }\n        if (_this4._connectionState === \"Connecting\" /* Connecting */) {\n          // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n          // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n          _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"The HttpConnection connected successfully.\");\n          _this4._connectionState = \"Connected\" /* Connected */;\n        }\n        // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\n        // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\n        // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\n      } catch (e) {\n        _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"Failed to start the connection: \" + e);\n        _this4._connectionState = \"Disconnected\" /* Disconnected */;\n        _this4.transport = undefined;\n        // if start fails, any active calls to stop assume that start will complete the stop promise\n        _this4._stopPromiseResolver();\n        return Promise.reject(e);\n      }\n    })();\n  }\n  _getNegotiationResponse(url) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var headers = {};\n      var [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getUserAgentHeader)();\n      headers[name] = value;\n      var negotiateUrl = _this5._resolveNegotiateUrl(url);\n      _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Sending negotiation request: \".concat(negotiateUrl, \".\"));\n      try {\n        var response = yield _this5._httpClient.post(negotiateUrl, {\n          content: \"\",\n          headers: _objectSpread(_objectSpread({}, headers), _this5._options.headers),\n          timeout: _this5._options.timeout,\n          withCredentials: _this5._options.withCredentials\n        });\n        if (response.statusCode !== 200) {\n          return Promise.reject(new Error(\"Unexpected status code returned from negotiate '\".concat(response.statusCode, \"'\")));\n        }\n        var negotiateResponse = JSON.parse(response.content);\n        if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n          // Negotiate version 0 doesn't use connectionToken\n          // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n          negotiateResponse.connectionToken = negotiateResponse.connectionId;\n        }\n        return negotiateResponse;\n      } catch (e) {\n        var errorMessage = \"Failed to complete negotiation with the server: \" + e;\n        if (e instanceof _Errors__WEBPACK_IMPORTED_MODULE_5__.HttpError) {\n          if (e.statusCode === 404) {\n            errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\n          }\n        }\n        _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, errorMessage);\n        return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_5__.FailedToNegotiateWithServerError(errorMessage));\n      }\n    })();\n  }\n  _createConnectUrl(url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + \"id=\".concat(connectionToken);\n  }\n  _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var connectUrl = _this6._createConnectUrl(url, negotiateResponse.connectionToken);\n      if (_this6._isITransport(requestedTransport)) {\n        _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n        _this6.transport = requestedTransport;\n        yield _this6._startTransport(connectUrl, requestedTransferFormat);\n        _this6.connectionId = negotiateResponse.connectionId;\n        return;\n      }\n      var transportExceptions = [];\n      var transports = negotiateResponse.availableTransports || [];\n      var negotiate = negotiateResponse;\n      for (var endpoint of transports) {\n        var transportOrError = _this6._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n        if (transportOrError instanceof Error) {\n          // Store the error and continue, we don't want to cause a re-negotiate in these cases\n          transportExceptions.push(\"\".concat(endpoint.transport, \" failed:\"));\n          transportExceptions.push(transportOrError);\n        } else if (_this6._isITransport(transportOrError)) {\n          _this6.transport = transportOrError;\n          if (!negotiate) {\n            try {\n              negotiate = yield _this6._getNegotiationResponse(url);\n            } catch (ex) {\n              return Promise.reject(ex);\n            }\n            connectUrl = _this6._createConnectUrl(url, negotiate.connectionToken);\n          }\n          try {\n            yield _this6._startTransport(connectUrl, requestedTransferFormat);\n            _this6.connectionId = negotiate.connectionId;\n            return;\n          } catch (ex) {\n            _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"Failed to start the transport '\".concat(endpoint.transport, \"': \").concat(ex));\n            negotiate = undefined;\n            transportExceptions.push(new _Errors__WEBPACK_IMPORTED_MODULE_5__.FailedToStartTransportError(\"\".concat(endpoint.transport, \" failed: \").concat(ex), _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[endpoint.transport]));\n            if (_this6._connectionState !== \"Connecting\" /* Connecting */) {\n              var message = \"Failed to select transport before stop() was called.\";\n              _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, message);\n              return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_5__.AbortError(message));\n            }\n          }\n        }\n      }\n      if (transportExceptions.length > 0) {\n        return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_5__.AggregateErrors(\"Unable to connect to the server with any of the available transports. \".concat(transportExceptions.join(\" \")), transportExceptions));\n      }\n      return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n    })();\n  }\n  _constructTransport(transport) {\n    switch (transport) {\n      case _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.WebSockets:\n        if (!this._options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n        return new _WebSocketTransport__WEBPACK_IMPORTED_MODULE_7__.WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\n      case _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.ServerSentEvents:\n        if (!this._options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n        return new _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_8__.ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\n      case _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.LongPolling:\n        return new _LongPollingTransport__WEBPACK_IMPORTED_MODULE_6__.LongPollingTransport(this._httpClient, this._logger, this._options);\n      default:\n        throw new Error(\"Unknown transport: \".concat(transport, \".\"));\n    }\n  }\n  _startTransport(url, transferFormat) {\n    this.transport.onreceive = this.onreceive;\n    this.transport.onclose = e => this._stopConnection(e);\n    return this.transport.connect(url, transferFormat);\n  }\n  _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[endpoint.transport];\n    if (transport === null || transport === undefined) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Skipping transport '\".concat(endpoint.transport, \"' because it is not supported by this client.\"));\n      return new Error(\"Skipping transport '\".concat(endpoint.transport, \"' because it is not supported by this client.\"));\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        var transferFormats = endpoint.transferFormats.map(s => _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat[s]);\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.WebSockets && !this._options.WebSocket || transport === _ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType.ServerSentEvents && !this._options.EventSource) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Skipping transport '\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' because it is not supported in your environment.'\"));\n            return new _Errors__WEBPACK_IMPORTED_MODULE_5__.UnsupportedTransportError(\"'\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' is not supported in your environment.\"), transport);\n          } else {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Selecting transport '\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"'.\"));\n            try {\n              return this._constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Skipping transport '\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' because it does not support the requested transfer format '\").concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat[requestedTransferFormat], \"'.\"));\n          return new Error(\"'\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' does not support \").concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat[requestedTransferFormat], \".\"));\n        }\n      } else {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Skipping transport '\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' because it was disabled by the client.\"));\n        return new _Errors__WEBPACK_IMPORTED_MODULE_5__.DisabledTransportError(\"'\".concat(_ITransport__WEBPACK_IMPORTED_MODULE_3__.HttpTransportType[transport], \"' is disabled by the client.\"), transport);\n      }\n    }\n  }\n  _isITransport(transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  }\n  _stopConnection(error) {\n    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"HttpConnection.stopConnection(\".concat(error, \") called while in state \").concat(this._connectionState, \".\"));\n    this.transport = undefined;\n    // If we have a stopError, it takes precedence over the error from the transport\n    error = this._stopError || error;\n    this._stopError = undefined;\n    if (this._connectionState === \"Disconnected\" /* Disconnected */) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug, \"Call to HttpConnection.stopConnection(\".concat(error, \") was ignored because the connection is already in the disconnected state.\"));\n      return;\n    }\n    if (this._connectionState === \"Connecting\" /* Connecting */) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Warning, \"Call to HttpConnection.stopConnection(\".concat(error, \") was ignored because the connection is still in the connecting state.\"));\n      throw new Error(\"HttpConnection.stopConnection(\".concat(error, \") was called while the connection is still in the connecting state.\"));\n    }\n    if (this._connectionState === \"Disconnecting\" /* Disconnecting */) {\n      // A call to stop() induced this call to stopConnection and needs to be completed.\n      // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n      this._stopPromiseResolver();\n    }\n    if (error) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"Connection disconnected with error '\".concat(error, \"'.\"));\n    } else {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Information, \"Connection disconnected.\");\n    }\n    if (this._sendQueue) {\n      this._sendQueue.stop().catch(e => {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"TransportSendQueue.stop() threw error '\".concat(e, \"'.\"));\n      });\n      this._sendQueue = undefined;\n    }\n    this.connectionId = undefined;\n    this._connectionState = \"Disconnected\" /* Disconnected */;\n    if (this._connectionStarted) {\n      this._connectionStarted = false;\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Error, \"HttpConnection.onclose(\".concat(error, \") threw error '\").concat(e, \"'.\"));\n      }\n    }\n  }\n  _resolveUrl(url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isBrowser) {\n      throw new Error(\"Cannot resolve '\".concat(url, \"'.\"));\n    }\n    // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Information, \"Normalizing '\".concat(url, \"' to '\").concat(aTag.href, \"'.\"));\n    return aTag.href;\n  }\n  _resolveNegotiateUrl(url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\n    }\n    return negotiateUrl;\n  }\n}\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\nclass TransportSendQueue {\n  constructor(_transport) {\n    this._transport = _transport;\n    this._buffer = [];\n    this._executing = true;\n    this._sendBufferedData = new PromiseSource();\n    this._transportResult = new PromiseSource();\n    this._sendLoopPromise = this._sendLoop();\n  }\n  send(data) {\n    this._bufferData(data);\n    if (!this._transportResult) {\n      this._transportResult = new PromiseSource();\n    }\n    return this._transportResult.promise;\n  }\n  stop() {\n    this._executing = false;\n    this._sendBufferedData.resolve();\n    return this._sendLoopPromise;\n  }\n  _bufferData(data) {\n    if (this._buffer.length && typeof this._buffer[0] !== typeof data) {\n      throw new Error(\"Expected data to be of type \".concat(typeof this._buffer, \" but was of type \").concat(typeof data));\n    }\n    this._buffer.push(data);\n    this._sendBufferedData.resolve();\n  }\n  _sendLoop() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      while (true) {\n        yield _this7._sendBufferedData.promise;\n        if (!_this7._executing) {\n          if (_this7._transportResult) {\n            _this7._transportResult.reject(\"Connection stopped.\");\n          }\n          break;\n        }\n        _this7._sendBufferedData = new PromiseSource();\n        var transportResult = _this7._transportResult;\n        _this7._transportResult = undefined;\n        var data = typeof _this7._buffer[0] === \"string\" ? _this7._buffer.join(\"\") : TransportSendQueue._concatBuffers(_this7._buffer);\n        _this7._buffer.length = 0;\n        try {\n          yield _this7._transport.send(data);\n          transportResult.resolve();\n        } catch (error) {\n          transportResult.reject(error);\n        }\n      }\n    })();\n  }\n  static _concatBuffers(arrayBuffers) {\n    var totalLength = arrayBuffers.map(b => b.byteLength).reduce((a, b) => a + b);\n    var result = new Uint8Array(totalLength);\n    var offset = 0;\n    for (var item of arrayBuffers) {\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n    return result.buffer;\n  }\n}\nclass PromiseSource {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\n  }\n  resolve() {\n    this._resolver();\n  }\n  reject(reason) {\n    this._rejecter(reason);\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HubConnection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HubConnection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HubConnection: () => (/* binding */ HubConnection),\n/* harmony export */   HubConnectionState: () => (/* binding */ HubConnectionState)\n/* harmony export */ });\n/* harmony import */ var _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HandshakeProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IHubProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Subject */ \"./node_modules/@microsoft/signalr/dist/esm/Subject.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\nvar HubConnectionState;\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\nclass HubConnection {\n  constructor(connection, logger, protocol, reconnectPolicy) {\n    this._nextKeepAlive = 0;\n    this._freezeEventListener = () => {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n    };\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(connection, \"connection\");\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(logger, \"logger\");\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this._logger = logger;\n    this._protocol = protocol;\n    this.connection = connection;\n    this._reconnectPolicy = reconnectPolicy;\n    this._handshakeProtocol = new _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_2__.HandshakeProtocol();\n    this.connection.onreceive = data => this._processIncomingData(data);\n    this.connection.onclose = error => this._connectionClosed(error);\n    this._callbacks = {};\n    this._methods = {};\n    this._closedCallbacks = [];\n    this._reconnectingCallbacks = [];\n    this._reconnectedCallbacks = [];\n    this._invocationId = 0;\n    this._receivedHandshakeResponse = false;\n    this._connectionState = HubConnectionState.Disconnected;\n    this._connectionStarted = false;\n    this._cachedPingMessage = this._protocol.writeMessage({\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n  static create(connection, logger, protocol, reconnectPolicy) {\n    return new HubConnection(connection, logger, protocol, reconnectPolicy);\n  }\n  /** Indicates the state of the {@link HubConnection} to the server. */\n  get state() {\n    return this._connectionState;\n  }\n  /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n   *  in the disconnected state or if the negotiation step was skipped.\r\n   */\n  get connectionId() {\n    return this.connection ? this.connection.connectionId || null : null;\n  }\n  /** Indicates the url of the {@link HubConnection} to the server. */\n  get baseUrl() {\n    return this.connection.baseUrl || \"\";\n  }\n  /**\r\n   * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n   * Reconnecting states.\r\n   * @param {string} url The url to connect to.\r\n   */\n  set baseUrl(url) {\n    if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\n      throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n    }\n    if (!url) {\n      throw new Error(\"The HubConnection url must be a valid url.\");\n    }\n    this.connection.baseUrl = url;\n  }\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n  start() {\n    this._startPromise = this._startWithStateTransitions();\n    return this._startPromise;\n  }\n  _startWithStateTransitions() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this._connectionState !== HubConnectionState.Disconnected) {\n        return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\n      }\n      _this._connectionState = HubConnectionState.Connecting;\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Starting HubConnection.\");\n      try {\n        yield _this._startInternal();\n        if (_Utils__WEBPACK_IMPORTED_MODULE_1__.Platform.isBrowser) {\n          // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\n          window.document.addEventListener(\"freeze\", _this._freezeEventListener);\n        }\n        _this._connectionState = HubConnectionState.Connected;\n        _this._connectionStarted = true;\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"HubConnection connected successfully.\");\n      } catch (e) {\n        _this._connectionState = HubConnectionState.Disconnected;\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"HubConnection failed to start successfully because of error '\".concat(e, \"'.\"));\n        return Promise.reject(e);\n      }\n    })();\n  }\n  _startInternal() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2._stopDuringStartError = undefined;\n      _this2._receivedHandshakeResponse = false;\n      // Set up the promise before any connection is (re)started otherwise it could race with received messages\n      var handshakePromise = new Promise((resolve, reject) => {\n        _this2._handshakeResolver = resolve;\n        _this2._handshakeRejecter = reject;\n      });\n      yield _this2.connection.start(_this2._protocol.transferFormat);\n      try {\n        var handshakeRequest = {\n          protocol: _this2._protocol.name,\n          version: _this2._protocol.version\n        };\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Sending handshake request.\");\n        yield _this2._sendMessage(_this2._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Using HubProtocol '\".concat(_this2._protocol.name, \"'.\"));\n        // defensively cleanup timeout in case we receive a message from the server before we finish start\n        _this2._cleanupTimeout();\n        _this2._resetTimeoutPeriod();\n        _this2._resetKeepAliveInterval();\n        yield handshakePromise;\n        // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n        // being rejected on close, because this continuation can run after both the handshake completed successfully\n        // and the connection was closed.\n        if (_this2._stopDuringStartError) {\n          // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n          // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n          // will cause the calling continuation to get scheduled to run later.\n          // eslint-disable-next-line @typescript-eslint/no-throw-literal\n          throw _this2._stopDuringStartError;\n        }\n        if (!_this2.connection.features.inherentKeepAlive) {\n          yield _this2._sendMessage(_this2._cachedPingMessage);\n        }\n      } catch (e) {\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Hub handshake failed with error '\".concat(e, \"' during start(). Stopping HubConnection.\"));\n        _this2._cleanupTimeout();\n        _this2._cleanupPingTimer();\n        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n        yield _this2.connection.stop(e);\n        throw e;\n      }\n    })();\n  }\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n  stop() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Capture the start promise before the connection might be restarted in an onclose callback.\n      var startPromise = _this3._startPromise;\n      _this3._stopPromise = _this3._stopInternal();\n      yield _this3._stopPromise;\n      try {\n        // Awaiting undefined continues immediately\n        yield startPromise;\n      } catch (e) {\n        // This exception is returned to the user as a rejected Promise from the start method.\n      }\n    })();\n  }\n  _stopInternal(error) {\n    if (this._connectionState === HubConnectionState.Disconnected) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Call to HubConnection.stop(\".concat(error, \") ignored because it is already in the disconnected state.\"));\n      return Promise.resolve();\n    }\n    if (this._connectionState === HubConnectionState.Disconnecting) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnecting state.\"));\n      return this._stopPromise;\n    }\n    this._connectionState = HubConnectionState.Disconnecting;\n    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Stopping HubConnection.\");\n    if (this._reconnectDelayHandle) {\n      // We're in a reconnect delay which means the underlying connection is currently already stopped.\n      // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n      // fire the onclose callbacks.\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n      clearTimeout(this._reconnectDelayHandle);\n      this._reconnectDelayHandle = undefined;\n      this._completeClose();\n      return Promise.resolve();\n    }\n    this._cleanupTimeout();\n    this._cleanupPingTimer();\n    this._stopDuringStartError = error || new _Errors__WEBPACK_IMPORTED_MODULE_4__.AbortError(\"The connection was stopped before the hub handshake could complete.\");\n    // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n    // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n    // to the disconnected state if need be before HttpConnection.stop() completes.\n    return this.connection.stop(error);\n  }\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n  stream(methodName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var [streams, streamIds] = this._replaceStreamingParams(args);\n    var invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\n    // eslint-disable-next-line prefer-const\n    var promiseQueue;\n    var subject = new _Subject__WEBPACK_IMPORTED_MODULE_5__.Subject();\n    subject.cancelCallback = () => {\n      var cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\n      delete this._callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(() => {\n        return this._sendWithProtocol(cancelInvocation);\n      });\n    };\n    this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n    promiseQueue = this._sendWithProtocol(invocationDescriptor).catch(e => {\n      subject.error(e);\n      delete this._callbacks[invocationDescriptor.invocationId];\n    });\n    this._launchStreams(streams, promiseQueue);\n    return subject;\n  }\n  _sendMessage(message) {\n    this._resetKeepAliveInterval();\n    return this.connection.send(message);\n  }\n  /**\r\n   * Sends a js object to the server.\r\n   * @param message The js object to serialize and send.\r\n   */\n  _sendWithProtocol(message) {\n    return this._sendMessage(this._protocol.writeMessage(message));\n  }\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n  send(methodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var [streams, streamIds] = this._replaceStreamingParams(args);\n    var sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\n    this._launchStreams(streams, sendPromise);\n    return sendPromise;\n  }\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n  invoke(methodName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    var [streams, streamIds] = this._replaceStreamingParams(args);\n    var invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\n    var p = new Promise((resolve, reject) => {\n      // invocationId will always have a value for a non-blocking invocation\n      this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \".concat(invocationEvent.type)));\n          }\n        }\n      };\n      var promiseQueue = this._sendWithProtocol(invocationDescriptor).catch(e => {\n        reject(e);\n        // invocationId will always have a value for a non-blocking invocation\n        delete this._callbacks[invocationDescriptor.invocationId];\n      });\n      this._launchStreams(streams, promiseQueue);\n    });\n    return p;\n  }\n  on(methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    if (!this._methods[methodName]) {\n      this._methods[methodName] = [];\n    }\n    // Preventing adding the same handler multiple times.\n    if (this._methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n    this._methods[methodName].push(newMethod);\n  }\n  off(methodName, method) {\n    if (!methodName) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    var handlers = this._methods[methodName];\n    if (!handlers) {\n      return;\n    }\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n        if (handlers.length === 0) {\n          delete this._methods[methodName];\n        }\n      }\n    } else {\n      delete this._methods[methodName];\n    }\n  }\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n  onclose(callback) {\n    if (callback) {\n      this._closedCallbacks.push(callback);\n    }\n  }\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n   */\n  onreconnecting(callback) {\n    if (callback) {\n      this._reconnectingCallbacks.push(callback);\n    }\n  }\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n   */\n  onreconnected(callback) {\n    if (callback) {\n      this._reconnectedCallbacks.push(callback);\n    }\n  }\n  _processIncomingData(data) {\n    this._cleanupTimeout();\n    if (!this._receivedHandshakeResponse) {\n      data = this._processHandshakeResponse(data);\n      this._receivedHandshakeResponse = true;\n    }\n    // Data may have all been read when processing handshake response\n    if (data) {\n      // Parse the messages\n      var messages = this._protocol.parseMessages(data, this._logger);\n      for (var message of messages) {\n        switch (message.type) {\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation:\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._invokeClientMethod(message);\n            break;\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.StreamItem:\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion:\n            {\n              var callback = this._callbacks[message.invocationId];\n              if (callback) {\n                if (message.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion) {\n                  delete this._callbacks[message.invocationId];\n                }\n                try {\n                  callback(message);\n                } catch (e) {\n                  this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"Stream callback threw error: \".concat((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getErrorString)(e)));\n                }\n              }\n              break;\n            }\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Ping:\n            // Don't care about pings\n            break;\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Close:\n            {\n              this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Close message received from server.\");\n              var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n              if (message.allowReconnect === true) {\n                // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n                // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this.connection.stop(error);\n              } else {\n                // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n                this._stopPromise = this._stopInternal(error);\n              }\n              break;\n            }\n          default:\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning, \"Invalid message type: \".concat(message.type, \".\"));\n            break;\n        }\n      }\n    }\n    this._resetTimeoutPeriod();\n  }\n  _processHandshakeResponse(data) {\n    var responseMessage;\n    var remainingData;\n    try {\n      [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, message);\n      var error = new Error(message);\n      this._handshakeRejecter(error);\n      throw error;\n    }\n    if (responseMessage.error) {\n      var _message = \"Server returned handshake error: \" + responseMessage.error;\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, _message);\n      var _error = new Error(_message);\n      this._handshakeRejecter(_error);\n      throw _error;\n    } else {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Server handshake complete.\");\n    }\n    this._handshakeResolver();\n    return remainingData;\n  }\n  _resetKeepAliveInterval() {\n    if (this.connection.features.inherentKeepAlive) {\n      return;\n    }\n    // Set the time we want the next keep alive to be sent\n    // Timer will be setup on next message receive\n    this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n    this._cleanupPingTimer();\n  }\n  _resetTimeoutPeriod() {\n    var _this4 = this;\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\n      // Set keepAlive timer if there isn't one\n      if (this._pingServerHandle === undefined) {\n        var nextPing = this._nextKeepAlive - new Date().getTime();\n        if (nextPing < 0) {\n          nextPing = 0;\n        }\n        // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n        this._pingServerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n          if (_this4._connectionState === HubConnectionState.Connected) {\n            try {\n              yield _this4._sendMessage(_this4._cachedPingMessage);\n            } catch (_unused) {\n              // We don't care about the error. It should be seen elsewhere in the client.\n              // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n              _this4._cleanupPingTimer();\n            }\n          }\n        }), nextPing);\n      }\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  serverTimeout() {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  }\n  _invokeClientMethod(invocationMessage) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var methodName = invocationMessage.target.toLowerCase();\n      var methods = _this5._methods[methodName];\n      if (!methods) {\n        _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning, \"No client method with the name '\".concat(methodName, \"' found.\"));\n        // No handlers provided by client but the server is expecting a response still, so we send an error\n        if (invocationMessage.invocationId) {\n          _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning, \"No result given for '\".concat(methodName, \"' method and invocation ID '\").concat(invocationMessage.invocationId, \"'.\"));\n          yield _this5._sendWithProtocol(_this5._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\n        }\n        return;\n      }\n      // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\n      var methodsCopy = methods.slice();\n      // Server expects a response\n      var expectsResponse = invocationMessage.invocationId ? true : false;\n      // We preserve the last result or exception but still call all handlers\n      var res;\n      var exception;\n      var completionMessage;\n      for (var m of methodsCopy) {\n        try {\n          var prevRes = res;\n          res = yield m.apply(_this5, invocationMessage.arguments);\n          if (expectsResponse && res && prevRes) {\n            _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"Multiple results provided for '\".concat(methodName, \"'. Sending error to server.\"));\n            completionMessage = _this5._createCompletionMessage(invocationMessage.invocationId, \"Client provided multiple results.\", null);\n          }\n          // Ignore exception if we got a result after, the exception will be logged\n          exception = undefined;\n        } catch (e) {\n          exception = e;\n          _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"A callback for the method '\".concat(methodName, \"' threw error '\").concat(e, \"'.\"));\n        }\n      }\n      if (completionMessage) {\n        yield _this5._sendWithProtocol(completionMessage);\n      } else if (expectsResponse) {\n        // If there is an exception that means either no result was given or a handler after a result threw\n        if (exception) {\n          completionMessage = _this5._createCompletionMessage(invocationMessage.invocationId, \"\".concat(exception), null);\n        } else if (res !== undefined) {\n          completionMessage = _this5._createCompletionMessage(invocationMessage.invocationId, null, res);\n        } else {\n          _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning, \"No result given for '\".concat(methodName, \"' method and invocation ID '\").concat(invocationMessage.invocationId, \"'.\"));\n          // Client didn't provide a result or throw from a handler, server expects a response so we send an error\n          completionMessage = _this5._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\n        }\n        yield _this5._sendWithProtocol(completionMessage);\n      } else {\n        if (res) {\n          _this5._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"Result given for '\".concat(methodName, \"' method but server is not expecting a result.\"));\n        }\n      }\n    })();\n  }\n  _connectionClosed(error) {\n    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"HubConnection.connectionClosed(\".concat(error, \") called while in state \").concat(this._connectionState, \".\"));\n    // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n    this._stopDuringStartError = this._stopDuringStartError || error || new _Errors__WEBPACK_IMPORTED_MODULE_4__.AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\n    // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n    // If it has already completed, this should just noop.\n    if (this._handshakeResolver) {\n      this._handshakeResolver();\n    }\n    this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n    this._cleanupTimeout();\n    this._cleanupPingTimer();\n    if (this._connectionState === HubConnectionState.Disconnecting) {\n      this._completeClose(error);\n    } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._reconnect(error);\n    } else if (this._connectionState === HubConnectionState.Connected) {\n      this._completeClose(error);\n    }\n    // If none of the above if conditions were true were called the HubConnection must be in either:\n    // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n    // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n    //    and potentially continue the reconnect() loop.\n    // 3. The Disconnected state in which case we're already done.\n  }\n\n  _completeClose(error) {\n    if (this._connectionStarted) {\n      this._connectionState = HubConnectionState.Disconnected;\n      this._connectionStarted = false;\n      if (_Utils__WEBPACK_IMPORTED_MODULE_1__.Platform.isBrowser) {\n        window.document.removeEventListener(\"freeze\", this._freezeEventListener);\n      }\n      try {\n        this._closedCallbacks.forEach(c => c.apply(this, [error]));\n      } catch (e) {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"An onclose callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n      }\n    }\n  }\n  _reconnect(error) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var reconnectStartTime = Date.now();\n      var previousReconnectAttempts = 0;\n      var retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n      var nextRetryDelay = _this6._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n      if (nextRetryDelay === null) {\n        _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n        _this6._completeClose(error);\n        return;\n      }\n      _this6._connectionState = HubConnectionState.Reconnecting;\n      if (error) {\n        _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Connection reconnecting because of error '\".concat(error, \"'.\"));\n      } else {\n        _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Connection reconnecting.\");\n      }\n      if (_this6._reconnectingCallbacks.length !== 0) {\n        try {\n          _this6._reconnectingCallbacks.forEach(c => c.apply(_this6, [error]));\n        } catch (e) {\n          _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"An onreconnecting callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n        }\n        // Exit early if an onreconnecting callback called connection.stop().\n        if (_this6._connectionState !== HubConnectionState.Reconnecting) {\n          _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n          return;\n        }\n      }\n      while (nextRetryDelay !== null) {\n        _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Reconnect attempt number \".concat(previousReconnectAttempts, \" will start in \").concat(nextRetryDelay, \" ms.\"));\n        yield new Promise(resolve => {\n          _this6._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n        });\n        _this6._reconnectDelayHandle = undefined;\n        if (_this6._connectionState !== HubConnectionState.Reconnecting) {\n          _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n          return;\n        }\n        try {\n          yield _this6._startInternal();\n          _this6._connectionState = HubConnectionState.Connected;\n          _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"HubConnection reconnected successfully.\");\n          if (_this6._reconnectedCallbacks.length !== 0) {\n            try {\n              _this6._reconnectedCallbacks.forEach(c => c.apply(_this6, [_this6.connection.connectionId]));\n            } catch (e) {\n              _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"An onreconnected callback called with connectionId '\".concat(_this6.connection.connectionId, \"; threw error '\").concat(e, \"'.\"));\n            }\n          }\n          return;\n        } catch (e) {\n          _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Reconnect attempt failed because of error '\".concat(e, \"'.\"));\n          if (_this6._connectionState !== HubConnectionState.Reconnecting) {\n            _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug, \"Connection moved to the '\".concat(_this6._connectionState, \"' from the reconnecting state during reconnect attempt. Done reconnecting.\"));\n            // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n            if (_this6._connectionState === HubConnectionState.Disconnecting) {\n              _this6._completeClose();\n            }\n            return;\n          }\n          retryError = e instanceof Error ? e : new Error(e.toString());\n          nextRetryDelay = _this6._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n        }\n      }\n      _this6._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, \"Reconnect retries have been exhausted after \".concat(Date.now() - reconnectStartTime, \" ms and \").concat(previousReconnectAttempts, \" failed attempts. Connection disconnecting.\"));\n      _this6._completeClose();\n    })();\n  }\n  _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\n    try {\n      return this._reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds,\n        previousRetryCount,\n        retryReason\n      });\n    } catch (e) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\".concat(previousRetryCount, \", \").concat(elapsedMilliseconds, \") threw error '\").concat(e, \"'.\"));\n      return null;\n    }\n  }\n  _cancelCallbacksWithError(error) {\n    var callbacks = this._callbacks;\n    this._callbacks = {};\n    Object.keys(callbacks).forEach(key => {\n      var callback = callbacks[key];\n      try {\n        callback(null, error);\n      } catch (e) {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error, \"Stream 'error' callback called with '\".concat(error, \"' threw error: \").concat((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getErrorString)(e)));\n      }\n    });\n  }\n  _cleanupPingTimer() {\n    if (this._pingServerHandle) {\n      clearTimeout(this._pingServerHandle);\n      this._pingServerHandle = undefined;\n    }\n  }\n  _cleanupTimeout() {\n    if (this._timeoutHandle) {\n      clearTimeout(this._timeoutHandle);\n    }\n  }\n  _createInvocation(methodName, args, nonblocking, streamIds) {\n    if (nonblocking) {\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          streamIds,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation\n        };\n      }\n    } else {\n      var invocationId = this._invocationId;\n      this._invocationId++;\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation\n        };\n      }\n    }\n  }\n  _launchStreams(streams, promiseQueue) {\n    var _this7 = this;\n    if (streams.length === 0) {\n      return;\n    }\n    // Synchronize stream data so they arrive in-order on the server\n    if (!promiseQueue) {\n      promiseQueue = Promise.resolve();\n    }\n    // We want to iterate over the keys, since the keys are the stream ids\n    // eslint-disable-next-line guard-for-in\n    var _loop = function _loop(streamId) {\n      streams[streamId].subscribe({\n        complete: () => {\n          promiseQueue = promiseQueue.then(() => _this7._sendWithProtocol(_this7._createCompletionMessage(streamId)));\n        },\n        error: err => {\n          var message;\n          if (err instanceof Error) {\n            message = err.message;\n          } else if (err && err.toString) {\n            message = err.toString();\n          } else {\n            message = \"Unknown error\";\n          }\n          promiseQueue = promiseQueue.then(() => _this7._sendWithProtocol(_this7._createCompletionMessage(streamId, message)));\n        },\n        next: item => {\n          promiseQueue = promiseQueue.then(() => _this7._sendWithProtocol(_this7._createStreamItemMessage(streamId, item)));\n        }\n      });\n    };\n    for (var streamId in streams) {\n      _loop(streamId);\n    }\n  }\n  _replaceStreamingParams(args) {\n    var streams = [];\n    var streamIds = [];\n    for (var i = 0; i < args.length; i++) {\n      var argument = args[i];\n      if (this._isObservable(argument)) {\n        var streamId = this._invocationId;\n        this._invocationId++;\n        // Store the stream for later use\n        streams[streamId] = argument;\n        streamIds.push(streamId.toString());\n        // remove stream from args\n        args.splice(i, 1);\n      }\n    }\n    return [streams, streamIds];\n  }\n  _isObservable(arg) {\n    // This allows other stream implementations to just work (like rxjs)\n    return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n  }\n  _createStreamInvocation(methodName, args, streamIds) {\n    var invocationId = this._invocationId;\n    this._invocationId++;\n    if (streamIds.length !== 0) {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        streamIds,\n        target: methodName,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.StreamInvocation\n      };\n    } else {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        target: methodName,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.StreamInvocation\n      };\n    }\n  }\n  _createCancelInvocation(id) {\n    return {\n      invocationId: id,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.CancelInvocation\n    };\n  }\n  _createStreamItemMessage(id, item) {\n    return {\n      invocationId: id,\n      item,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.StreamItem\n    };\n  }\n  _createCompletionMessage(id, error, result) {\n    if (error) {\n      return {\n        error,\n        invocationId: id,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion\n      };\n    }\n    return {\n      invocationId: id,\n      result,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion\n    };\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HubConnection.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HubConnectionBuilder: () => (/* binding */ HubConnectionBuilder)\n/* harmony export */ });\n/* harmony import */ var _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultReconnectPolicy */ \"./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js\");\n/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HttpConnection */ \"./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js\");\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HubConnection */ \"./node_modules/@microsoft/signalr/dist/esm/HubConnection.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JsonHubProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@microsoft/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\n\nvar LogLevelNameMapping = {\n  trace: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace,\n  debug: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Debug,\n  info: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information,\n  information: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information,\n  warn: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning,\n  warning: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning,\n  error: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error,\n  critical: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Critical,\n  none: _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.None\n};\nfunction parseLogLevel(name) {\n  // Case-insensitive matching via lower-casing\n  // Yes, I know case-folding is a complicated problem in Unicode, but we only support\n  // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\n  var mapping = LogLevelNameMapping[name.toLowerCase()];\n  if (typeof mapping !== \"undefined\") {\n    return mapping;\n  } else {\n    throw new Error(\"Unknown log level: \".concat(name));\n  }\n}\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\nclass HubConnectionBuilder {\n  configureLogging(logging) {\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(logging, \"logging\");\n    if (isLogger(logging)) {\n      this.logger = logging;\n    } else if (typeof logging === \"string\") {\n      var logLevel = parseLogLevel(logging);\n      this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_1__.ConsoleLogger(logLevel);\n    } else {\n      this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_1__.ConsoleLogger(logging);\n    }\n    return this;\n  }\n  withUrl(url, transportTypeOrOptions) {\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(url, \"url\");\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isNotEmpty(url, \"url\");\n    this.url = url;\n    // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\n    // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\n    if (typeof transportTypeOrOptions === \"object\") {\n      this.httpConnectionOptions = _objectSpread(_objectSpread({}, this.httpConnectionOptions), transportTypeOrOptions);\n    } else {\n      this.httpConnectionOptions = _objectSpread(_objectSpread({}, this.httpConnectionOptions), {}, {\n        transport: transportTypeOrOptions\n      });\n    }\n    return this;\n  }\n  /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n   *\r\n   * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n   */\n  withHubProtocol(protocol) {\n    _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(protocol, \"protocol\");\n    this.protocol = protocol;\n    return this;\n  }\n  withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\n    if (this.reconnectPolicy) {\n      throw new Error(\"A reconnectPolicy has already been set.\");\n    }\n    if (!retryDelaysOrReconnectPolicy) {\n      this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_2__.DefaultReconnectPolicy();\n    } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\n      this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_2__.DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\n    } else {\n      this.reconnectPolicy = retryDelaysOrReconnectPolicy;\n    }\n    return this;\n  }\n  /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n   *\r\n   * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n   */\n  build() {\n    // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\n    // provided to configureLogger\n    var httpConnectionOptions = this.httpConnectionOptions || {};\n    // If it's 'null', the user **explicitly** asked for null, don't mess with it.\n    if (httpConnectionOptions.logger === undefined) {\n      // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\n      httpConnectionOptions.logger = this.logger;\n    }\n    // Now create the connection\n    if (!this.url) {\n      throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n    }\n    var connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_3__.HttpConnection(this.url, httpConnectionOptions);\n    return _HubConnection__WEBPACK_IMPORTED_MODULE_4__.HubConnection.create(connection, this.logger || _Loggers__WEBPACK_IMPORTED_MODULE_5__.NullLogger.instance, this.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_6__.JsonHubProtocol(), this.reconnectPolicy);\n  }\n}\nfunction isLogger(logger) {\n  return logger.log !== undefined;\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js":
/*!******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageType: () => (/* binding */ MessageType)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Defines the type of a Hub Message. */\nvar MessageType;\n(function (MessageType) {\n  /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\n  MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\n  /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\n  MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\n  /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\n  MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\n  /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\n  MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\n  /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\n  MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\n  /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\n  MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\n  /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\n  MessageType[MessageType[\"Close\"] = 7] = \"Close\";\n})(MessageType || (MessageType = {}));\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ILogger.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\nvar LogLevel;\n(function (LogLevel) {\n  /** Log level for very low severity diagnostic messages. */\n  LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n  /** Log level for low severity diagnostic messages. */\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  /** Log level for informational diagnostic messages. */\n  LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\n  /** Log level for diagnostic messages that indicate a non-fatal problem. */\n  LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\n  /** Log level for diagnostic messages that indicate a failure in the current operation. */\n  LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n  /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\n  LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\n  /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\n  LogLevel[LogLevel[\"None\"] = 6] = \"None\";\n})(LogLevel || (LogLevel = {}));\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/ILogger.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/ITransport.js":
/*!****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ITransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpTransportType: () => (/* binding */ HttpTransportType),\n/* harmony export */   TransferFormat: () => (/* binding */ TransferFormat)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\n/** Specifies a specific HTTP transport type. */\nvar HttpTransportType;\n(function (HttpTransportType) {\n  /** Specifies no transport preference. */\n  HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\n  /** Specifies the WebSockets transport. */\n  HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\n  /** Specifies the Server-Sent Events transport. */\n  HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\n  /** Specifies the Long Polling transport. */\n  HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\n})(HttpTransportType || (HttpTransportType = {}));\n/** Specifies the transfer format for a connection. */\nvar TransferFormat;\n(function (TransferFormat) {\n  /** Specifies that only text data will be transmitted over the connection. */\n  TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\n  /** Specifies that binary data will be transmitted over the connection. */\n  TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\n})(TransferFormat || (TransferFormat = {}));\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/ITransport.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonHubProtocol: () => (/* binding */ JsonHubProtocol)\n/* harmony export */ });\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IHubProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@microsoft/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextMessageFormat */ \"./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\nvar JSON_HUB_PROTOCOL_NAME = \"json\";\n/** Implements the JSON Hub Protocol. */\nclass JsonHubProtocol {\n  constructor() {\n    /** @inheritDoc */\n    this.name = JSON_HUB_PROTOCOL_NAME;\n    /** @inheritDoc */\n    this.version = 1;\n    /** @inheritDoc */\n    this.transferFormat = _ITransport__WEBPACK_IMPORTED_MODULE_0__.TransferFormat.Text;\n  }\n  /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n   *\r\n   * @param {string} input A string containing the serialized representation.\r\n   * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n   */\n  parseMessages(input, logger) {\n    // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\n    if (typeof input !== \"string\") {\n      throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n    }\n    if (!input) {\n      return [];\n    }\n    if (logger === null) {\n      logger = _Loggers__WEBPACK_IMPORTED_MODULE_1__.NullLogger.instance;\n    }\n    // Parse the messages\n    var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__.TextMessageFormat.parse(input);\n    var hubMessages = [];\n    for (var message of messages) {\n      var parsedMessage = JSON.parse(message);\n      if (typeof parsedMessage.type !== \"number\") {\n        throw new Error(\"Invalid payload.\");\n      }\n      switch (parsedMessage.type) {\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Invocation:\n          this._isInvocationMessage(parsedMessage);\n          break;\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.StreamItem:\n          this._isStreamItemMessage(parsedMessage);\n          break;\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Completion:\n          this._isCompletionMessage(parsedMessage);\n          break;\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Ping:\n          // Single value, no need to validate\n          break;\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_3__.MessageType.Close:\n          // All optional values, no need to validate\n          break;\n        default:\n          // Future protocol changes can add message types, old clients can ignore them\n          logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\n          continue;\n      }\n      hubMessages.push(parsedMessage);\n    }\n    return hubMessages;\n  }\n  /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n   *\r\n   * @param {HubMessage} message The message to write.\r\n   * @returns {string} A string containing the serialized representation of the message.\r\n   */\n  writeMessage(message) {\n    return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__.TextMessageFormat.write(JSON.stringify(message));\n  }\n  _isInvocationMessage(message) {\n    this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\n    if (message.invocationId !== undefined) {\n      this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\n    }\n  }\n  _isStreamItemMessage(message) {\n    this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\n    if (message.item === undefined) {\n      throw new Error(\"Invalid payload for StreamItem message.\");\n    }\n  }\n  _isCompletionMessage(message) {\n    if (message.result && message.error) {\n      throw new Error(\"Invalid payload for Completion message.\");\n    }\n    if (!message.result && message.error) {\n      this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\n    }\n    this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\n  }\n  _assertNotEmptyString(value, errorMessage) {\n    if (typeof value !== \"string\" || value === \"\") {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/Loggers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Loggers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullLogger: () => (/* binding */ NullLogger)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** A logger that does nothing when log messages are sent to it. */\nclass NullLogger {\n  constructor() {}\n  /** @inheritDoc */\n  // eslint-disable-next-line\n  log(_logLevel, _message) {}\n}\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\nNullLogger.instance = new NullLogger();\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/Loggers.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LongPollingTransport: () => (/* binding */ LongPollingTransport)\n/* harmony export */ });\n/* harmony import */ var _AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortController */ \"./node_modules/@microsoft/signalr/dist/esm/AbortController.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n// Not exported from 'index', this type is internal.\n/** @private */\nclass LongPollingTransport {\n  constructor(httpClient, logger, options) {\n    this._httpClient = httpClient;\n    this._logger = logger;\n    this._pollAbort = new _AbortController__WEBPACK_IMPORTED_MODULE_0__.AbortController();\n    this._options = options;\n    this._running = false;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  // This is an internal type, not exported from 'index' so this is really just internal.\n  get pollAborted() {\n    return this._pollAbort.aborted;\n  }\n  connect(url, transferFormat) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(url, \"url\");\n      _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isRequired(transferFormat, \"transferFormat\");\n      _Utils__WEBPACK_IMPORTED_MODULE_1__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_2__.TransferFormat, \"transferFormat\");\n      _this._url = url;\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Connecting.\");\n      // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\n      if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_2__.TransferFormat.Binary && typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\") {\n        throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n      }\n      var [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getUserAgentHeader)();\n      var headers = _objectSpread({\n        [name]: value\n      }, _this._options.headers);\n      var pollOptions = {\n        abortSignal: _this._pollAbort.signal,\n        headers,\n        timeout: 100000,\n        withCredentials: _this._options.withCredentials\n      };\n      if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_2__.TransferFormat.Binary) {\n        pollOptions.responseType = \"arraybuffer\";\n      }\n      // Make initial long polling request\n      // Server uses first long polling request to finish initializing connection and it returns without data\n      var pollUrl = \"\".concat(url, \"&_=\").concat(Date.now());\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) polling: \".concat(pollUrl, \".\"));\n      var response = yield _this._httpClient.get(pollUrl, pollOptions);\n      if (response.statusCode !== 200) {\n        _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, \"(LongPolling transport) Unexpected response code: \".concat(response.statusCode, \".\"));\n        // Mark running as false so that the poll immediately ends and runs the close logic\n        _this._closeError = new _Errors__WEBPACK_IMPORTED_MODULE_4__.HttpError(response.statusText || \"\", response.statusCode);\n        _this._running = false;\n      } else {\n        _this._running = true;\n      }\n      _this._receiving = _this._poll(_this._url, pollOptions);\n    })();\n  }\n  _poll(url, pollOptions) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        while (_this2._running) {\n          try {\n            var pollUrl = \"\".concat(url, \"&_=\").concat(Date.now());\n            _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) polling: \".concat(pollUrl, \".\"));\n            var response = yield _this2._httpClient.get(pollUrl, pollOptions);\n            if (response.statusCode === 204) {\n              _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\n              _this2._running = false;\n            } else if (response.statusCode !== 200) {\n              _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, \"(LongPolling transport) Unexpected response code: \".concat(response.statusCode, \".\"));\n              // Unexpected status code\n              _this2._closeError = new _Errors__WEBPACK_IMPORTED_MODULE_4__.HttpError(response.statusText || \"\", response.statusCode);\n              _this2._running = false;\n            } else {\n              // Process the response\n              if (response.content) {\n                _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) data received. \".concat((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getDataDetail)(response.content, _this2._options.logMessageContent), \".\"));\n                if (_this2.onreceive) {\n                  _this2.onreceive(response.content);\n                }\n              } else {\n                // This is another way timeout manifest.\n                _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n              }\n            }\n          } catch (e) {\n            if (!_this2._running) {\n              // Log but disregard errors that occur after stopping\n              _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Poll errored after shutdown: \".concat(e.message));\n            } else {\n              if (e instanceof _Errors__WEBPACK_IMPORTED_MODULE_4__.TimeoutError) {\n                // Ignore timeouts and reissue the poll.\n                _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n              } else {\n                // Close the connection with the error as the result.\n                _this2._closeError = e;\n                _this2._running = false;\n              }\n            }\n          }\n        }\n      } finally {\n        _this2._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\n        // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\n        // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\n        if (!_this2.pollAborted) {\n          _this2._raiseOnClose();\n        }\n      }\n    })();\n  }\n  send(data) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3._running) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n      return (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.sendMessage)(_this3._logger, \"LongPolling\", _this3._httpClient, _this3._url, data, _this3._options);\n    })();\n  }\n  stop() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\n      // Tell receiving loop to stop, abort any current request, and then wait for it to finish\n      _this4._running = false;\n      _this4._pollAbort.abort();\n      try {\n        yield _this4._receiving;\n        // Send DELETE to clean up long polling on the server\n        _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) sending DELETE request to \".concat(_this4._url, \".\"));\n        var headers = {};\n        var [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.getUserAgentHeader)();\n        headers[name] = value;\n        var deleteOptions = {\n          headers: _objectSpread(_objectSpread({}, headers), _this4._options.headers),\n          timeout: _this4._options.timeout,\n          withCredentials: _this4._options.withCredentials\n        };\n        yield _this4._httpClient.delete(_this4._url, deleteOptions);\n        _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\n      } finally {\n        _this4._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\n        // Raise close event here instead of in polling\n        // It needs to happen after the DELETE request is sent\n        _this4._raiseOnClose();\n      }\n    })();\n  }\n  _raiseOnClose() {\n    if (this.onclose) {\n      var logMessage = \"(LongPolling transport) Firing onclose event.\";\n      if (this._closeError) {\n        logMessage += \" Error: \" + this._closeError;\n      }\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace, logMessage);\n      this.onclose(this._closeError);\n    }\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerSentEventsTransport: () => (/* binding */ ServerSentEventsTransport)\n/* harmony export */ });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n/** @private */\nclass ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  connect(url, transferFormat) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isRequired(url, \"url\");\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isRequired(transferFormat, \"transferFormat\");\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat, \"transferFormat\");\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(SSE transport) Connecting.\");\n      // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n      _this._url = url;\n      if (_this._accessToken) {\n        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(_this._accessToken));\n      }\n      return new Promise((resolve, reject) => {\n        var opened = false;\n        if (transferFormat !== _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat.Text) {\n          reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n          return;\n        }\n        var eventSource;\n        if (_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isBrowser || _Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isWebWorker) {\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials\n          });\n        } else {\n          // Non-browser passes cookies via the dictionary\n          var cookies = _this._httpClient.getCookieString(url);\n          var headers = {};\n          headers.Cookie = cookies;\n          var [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getUserAgentHeader)();\n          headers[name] = value;\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials,\n            headers: _objectSpread(_objectSpread({}, headers), _this._options.headers)\n          });\n        }\n        try {\n          eventSource.onmessage = e => {\n            if (_this.onreceive) {\n              try {\n                _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(SSE transport) data received. \".concat((0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getDataDetail)(e.data, _this._options.logMessageContent), \".\"));\n                _this.onreceive(e.data);\n              } catch (error) {\n                _this._close(error);\n                return;\n              }\n            }\n          };\n          // @ts-ignore: not using event on purpose\n          eventSource.onerror = e => {\n            // EventSource doesn't give any useful information about server side closes.\n            if (opened) {\n              _this._close();\n            } else {\n              reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n            }\n          };\n          eventSource.onopen = () => {\n            _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Information, \"SSE connected to \".concat(_this._url));\n            _this._eventSource = eventSource;\n            opened = true;\n            resolve();\n          };\n        } catch (e) {\n          reject(e);\n          return;\n        }\n      });\n    })();\n  }\n  send(data) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2._eventSource) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n      return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.sendMessage)(_this2._logger, \"SSE\", _this2._httpClient, _this2._url, data, _this2._options);\n    })();\n  }\n  stop() {\n    this._close();\n    return Promise.resolve();\n  }\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n      this._eventSource = undefined;\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/Subject.js":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Subject.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subject: () => (/* binding */ Subject)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n/** Stream implementation to stream items to the server. */\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  next(item) {\n    for (var observer of this.observers) {\n      observer.next(item);\n    }\n  }\n  error(err) {\n    for (var observer of this.observers) {\n      if (observer.error) {\n        observer.error(err);\n      }\n    }\n  }\n  complete() {\n    for (var observer of this.observers) {\n      if (observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n  subscribe(observer) {\n    this.observers.push(observer);\n    return new _Utils__WEBPACK_IMPORTED_MODULE_0__.SubjectSubscription(this, observer);\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/Subject.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextMessageFormat: () => (/* binding */ TextMessageFormat)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Not exported from index\n/** @private */\nclass TextMessageFormat {\n  static write(output) {\n    return \"\".concat(output).concat(TextMessageFormat.RecordSeparator);\n  }\n  static parse(input) {\n    if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\n      throw new Error(\"Message is incomplete.\");\n    }\n    var messages = input.split(TextMessageFormat.RecordSeparator);\n    messages.pop();\n    return messages;\n  }\n}\nTextMessageFormat.RecordSeparatorCode = 0x1e;\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/Utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Arg: () => (/* binding */ Arg),\n/* harmony export */   ConsoleLogger: () => (/* binding */ ConsoleLogger),\n/* harmony export */   Platform: () => (/* binding */ Platform),\n/* harmony export */   SubjectSubscription: () => (/* binding */ SubjectSubscription),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   constructUserAgent: () => (/* binding */ constructUserAgent),\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   formatArrayBuffer: () => (/* binding */ formatArrayBuffer),\n/* harmony export */   getDataDetail: () => (/* binding */ getDataDetail),\n/* harmony export */   getErrorString: () => (/* binding */ getErrorString),\n/* harmony export */   getGlobalThis: () => (/* binding */ getGlobalThis),\n/* harmony export */   getUserAgentHeader: () => (/* binding */ getUserAgentHeader),\n/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage)\n/* harmony export */ });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@microsoft/signalr/dist/esm/Loggers.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n// Version token that will be replaced by the prepack command\n/** The version of the SignalR client. */\nvar VERSION = \"7.0.12\";\n/** @private */\nclass Arg {\n  static isRequired(val, name) {\n    if (val === null || val === undefined) {\n      throw new Error(\"The '\".concat(name, \"' argument is required.\"));\n    }\n  }\n  static isNotEmpty(val, name) {\n    if (!val || val.match(/^\\s*$/)) {\n      throw new Error(\"The '\".concat(name, \"' argument should not be empty.\"));\n    }\n  }\n  static isIn(val, values, name) {\n    // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n    if (!(val in values)) {\n      throw new Error(\"Unknown \".concat(name, \" value: \").concat(val, \".\"));\n    }\n  }\n}\n/** @private */\nclass Platform {\n  // react-native has a window but no document so we should check both\n  static get isBrowser() {\n    return typeof window === \"object\" && typeof window.document === \"object\";\n  }\n  // WebWorkers don't have a window object so the isBrowser check would fail\n  static get isWebWorker() {\n    return typeof self === \"object\" && \"importScripts\" in self;\n  }\n  // react-native has a window but no document\n  static get isReactNative() {\n    return typeof window === \"object\" && typeof window.document === \"undefined\";\n  }\n  // Node apps shouldn't have a window object, but WebWorkers don't either\n  // so we need to check for both WebWorker and window\n  static get isNode() {\n    return !this.isBrowser && !this.isWebWorker && !this.isReactNative;\n  }\n}\n/** @private */\nfunction getDataDetail(data, includeContent) {\n  var detail = \"\";\n  if (isArrayBuffer(data)) {\n    detail = \"Binary data of length \".concat(data.byteLength);\n    if (includeContent) {\n      detail += \". Content: '\".concat(formatArrayBuffer(data), \"'\");\n    }\n  } else if (typeof data === \"string\") {\n    detail = \"String data of length \".concat(data.length);\n    if (includeContent) {\n      detail += \". Content: '\".concat(data, \"'\");\n    }\n  }\n  return detail;\n}\n/** @private */\nfunction formatArrayBuffer(data) {\n  var view = new Uint8Array(data);\n  // Uint8Array.map only supports returning another Uint8Array?\n  var str = \"\";\n  view.forEach(num => {\n    var pad = num < 16 ? \"0\" : \"\";\n    str += \"0x\".concat(pad).concat(num.toString(16), \" \");\n  });\n  // Trim of trailing space.\n  return str.substr(0, str.length - 1);\n}\n// Also in signalr-protocol-msgpack/Utils.ts\n/** @private */\nfunction isArrayBuffer(val) {\n  return val && typeof ArrayBuffer !== \"undefined\" && (val instanceof ArrayBuffer ||\n  // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  val.constructor && val.constructor.name === \"ArrayBuffer\");\n}\n/** @private */\nfunction sendMessage(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _sendMessage.apply(this, arguments);\n}\n/** @private */\nfunction _sendMessage() {\n  _sendMessage = _asyncToGenerator(function* (logger, transportName, httpClient, url, content, options) {\n    var headers = {};\n    var [name, value] = getUserAgentHeader();\n    headers[name] = value;\n    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, \"(\".concat(transportName, \" transport) sending data. \").concat(getDataDetail(content, options.logMessageContent), \".\"));\n    var responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\n    var response = yield httpClient.post(url, {\n      content,\n      headers: _objectSpread(_objectSpread({}, headers), options.headers),\n      responseType,\n      timeout: options.timeout,\n      withCredentials: options.withCredentials\n    });\n    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, \"(\".concat(transportName, \" transport) request complete. Response status: \").concat(response.statusCode, \".\"));\n  });\n  return _sendMessage.apply(this, arguments);\n}\nfunction createLogger(logger) {\n  if (logger === undefined) {\n    return new ConsoleLogger(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information);\n  }\n  if (logger === null) {\n    return _Loggers__WEBPACK_IMPORTED_MODULE_1__.NullLogger.instance;\n  }\n  if (logger.log !== undefined) {\n    return logger;\n  }\n  return new ConsoleLogger(logger);\n}\n/** @private */\nclass SubjectSubscription {\n  constructor(subject, observer) {\n    this._subject = subject;\n    this._observer = observer;\n  }\n  dispose() {\n    var index = this._subject.observers.indexOf(this._observer);\n    if (index > -1) {\n      this._subject.observers.splice(index, 1);\n    }\n    if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\n      this._subject.cancelCallback().catch(_ => {});\n    }\n  }\n}\n/** @private */\nclass ConsoleLogger {\n  constructor(minimumLogLevel) {\n    this._minLevel = minimumLogLevel;\n    this.out = console;\n  }\n  log(logLevel, message) {\n    if (logLevel >= this._minLevel) {\n      var msg = \"[\".concat(new Date().toISOString(), \"] \").concat(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel[logLevel], \": \").concat(message);\n      switch (logLevel) {\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Critical:\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error:\n          this.out.error(msg);\n          break;\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning:\n          this.out.warn(msg);\n          break;\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information:\n          this.out.info(msg);\n          break;\n        default:\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n          this.out.log(msg);\n          break;\n      }\n    }\n  }\n}\n/** @private */\nfunction getUserAgentHeader() {\n  var userAgentHeaderName = \"X-SignalR-User-Agent\";\n  if (Platform.isNode) {\n    userAgentHeaderName = \"User-Agent\";\n  }\n  return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\n}\n/** @private */\nfunction constructUserAgent(version, os, runtime, runtimeVersion) {\n  // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\n  var userAgent = \"Microsoft SignalR/\";\n  var majorAndMinor = version.split(\".\");\n  userAgent += \"\".concat(majorAndMinor[0], \".\").concat(majorAndMinor[1]);\n  userAgent += \" (\".concat(version, \"; \");\n  if (os && os !== \"\") {\n    userAgent += \"\".concat(os, \"; \");\n  } else {\n    userAgent += \"Unknown OS; \";\n  }\n  userAgent += \"\".concat(runtime);\n  if (runtimeVersion) {\n    userAgent += \"; \".concat(runtimeVersion);\n  } else {\n    userAgent += \"; Unknown Runtime Version\";\n  }\n  userAgent += \")\";\n  return userAgent;\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/\nfunction getOsName() {\n  if (Platform.isNode) {\n    switch (process.platform) {\n      case \"win32\":\n        return \"Windows NT\";\n      case \"darwin\":\n        return \"macOS\";\n      case \"linux\":\n        return \"Linux\";\n      default:\n        return process.platform;\n    }\n  } else {\n    return \"\";\n  }\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/\nfunction getRuntimeVersion() {\n  if (Platform.isNode) {\n    return process.versions.node;\n  }\n  return undefined;\n}\nfunction getRuntime() {\n  if (Platform.isNode) {\n    return \"NodeJS\";\n  } else {\n    return \"Browser\";\n  }\n}\n/** @private */\nfunction getErrorString(e) {\n  if (e.stack) {\n    return e.stack;\n  } else if (e.message) {\n    return e.message;\n  }\n  return \"\".concat(e);\n}\n/** @private */\nfunction getGlobalThis() {\n  // globalThis is semi-new and not available in Node until v12\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  throw new Error(\"could not find global\");\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/Utils.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js":
/*!************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketTransport: () => (/* binding */ WebSocketTransport)\n/* harmony export */ });\n/* harmony import */ var _HeaderNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HeaderNames */ \"./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n/** @private */\nclass WebSocketTransport {\n  constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n  connect(url, transferFormat) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isRequired(url, \"url\");\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isRequired(transferFormat, \"transferFormat\");\n      _Utils__WEBPACK_IMPORTED_MODULE_0__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat, \"transferFormat\");\n      _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n      var token;\n      if (_this._accessTokenFactory) {\n        token = yield _this._accessTokenFactory();\n      }\n      return new Promise((resolve, reject) => {\n        url = url.replace(/^http/, \"ws\");\n        var webSocket;\n        var cookies = _this._httpClient.getCookieString(url);\n        var opened = false;\n        if (_Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isNode || _Utils__WEBPACK_IMPORTED_MODULE_0__.Platform.isReactNative) {\n          var headers = {};\n          var [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getUserAgentHeader)();\n          headers[name] = value;\n          if (token) {\n            headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_3__.HeaderNames.Authorization] = \"Bearer \".concat(token);\n          }\n          if (cookies) {\n            headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_3__.HeaderNames.Cookie] = cookies;\n          }\n          // Only pass headers when in non-browser environments\n          webSocket = new _this._webSocketConstructor(url, undefined, {\n            headers: _objectSpread(_objectSpread({}, headers), _this._headers)\n          });\n        } else {\n          if (token) {\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(token));\n          }\n        }\n        if (!webSocket) {\n          // Chrome is not happy with passing 'undefined' as protocol\n          webSocket = new _this._webSocketConstructor(url);\n        }\n        if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat.Binary) {\n          webSocket.binaryType = \"arraybuffer\";\n        }\n        webSocket.onopen = _event => {\n          _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Information, \"WebSocket connected to \".concat(url, \".\"));\n          _this._webSocket = webSocket;\n          opened = true;\n          resolve();\n        };\n        webSocket.onerror = event => {\n          var error = null;\n          // ErrorEvent is a browser only type we need to check if the type exists before using it\n          if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n            error = event.error;\n          } else {\n            error = \"There was an error with the transport\";\n          }\n          _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Information, \"(WebSockets transport) \".concat(error, \".\"));\n        };\n        webSocket.onmessage = message => {\n          _this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(WebSockets transport) data received. \".concat((0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getDataDetail)(message.data, _this._logMessageContent), \".\"));\n          if (_this.onreceive) {\n            try {\n              _this.onreceive(message.data);\n            } catch (error) {\n              _this._close(error);\n              return;\n            }\n          }\n        };\n        webSocket.onclose = event => {\n          // Don't call close handler if connection was never established\n          // We'll reject the connect call instead\n          if (opened) {\n            _this._close(event);\n          } else {\n            var error = null;\n            // ErrorEvent is a browser only type we need to check if the type exists before using it\n            if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n              error = event.error;\n            } else {\n              error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n            }\n            reject(new Error(error));\n          }\n        };\n      });\n    })();\n  }\n  send(data) {\n    if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n      this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(WebSockets transport) sending data. \".concat((0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getDataDetail)(data, this._logMessageContent), \".\"));\n      this._webSocket.send(data);\n      return Promise.resolve();\n    }\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n  stop() {\n    if (this._webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this._close(undefined);\n    }\n    return Promise.resolve();\n  }\n  _close(event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this._webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this._webSocket.onclose = () => {};\n      this._webSocket.onmessage = () => {};\n      this._webSocket.onerror = () => {};\n      this._webSocket.close();\n      this._webSocket = undefined;\n    }\n    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n    if (this.onclose) {\n      if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(\"WebSocket closed with status code: \".concat(event.code, \" (\").concat(event.reason || \"no reason given\", \").\")));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  }\n  _isCloseEvent(event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XhrHttpClient: () => (/* binding */ XhrHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/HttpClient.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\nclass XhrHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n  }\n  /** @inheritDoc */\n  send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_1__.AbortError());\n    }\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n    return new Promise((resolve, reject) => {\n      var xhr = new XMLHttpRequest();\n      xhr.open(request.method, request.url, true);\n      xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\n      xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n      if (request.content === \"\") {\n        request.content = undefined;\n      }\n      if (request.content) {\n        // Explicitly setting the Content-Type header for React Native on Android platform.\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isArrayBuffer)(request.content)) {\n          xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n        } else {\n          xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\n        }\n      }\n      var headers = request.headers;\n      if (headers) {\n        Object.keys(headers).forEach(header => {\n          xhr.setRequestHeader(header, headers[header]);\n        });\n      }\n      if (request.responseType) {\n        xhr.responseType = request.responseType;\n      }\n      if (request.abortSignal) {\n        request.abortSignal.onabort = () => {\n          xhr.abort();\n          reject(new _Errors__WEBPACK_IMPORTED_MODULE_1__.AbortError());\n        };\n      }\n      if (request.timeout) {\n        xhr.timeout = request.timeout;\n      }\n      xhr.onload = () => {\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(new _HttpClient__WEBPACK_IMPORTED_MODULE_0__.HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\n        } else {\n          reject(new _Errors__WEBPACK_IMPORTED_MODULE_1__.HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\n        }\n      };\n      xhr.onerror = () => {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, \"Error from HTTP request. \".concat(xhr.status, \": \").concat(xhr.statusText, \".\"));\n        reject(new _Errors__WEBPACK_IMPORTED_MODULE_1__.HttpError(xhr.statusText, xhr.status));\n      };\n      xhr.ontimeout = () => {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, \"Timeout from HTTP request.\");\n        reject(new _Errors__WEBPACK_IMPORTED_MODULE_1__.TimeoutError());\n      };\n      xhr.send(request.content);\n    });\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError),\n/* harmony export */   DefaultHttpClient: () => (/* reexport safe */ _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__.DefaultHttpClient),\n/* harmony export */   HttpClient: () => (/* reexport safe */ _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient),\n/* harmony export */   HttpError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.HttpError),\n/* harmony export */   HttpResponse: () => (/* reexport safe */ _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpResponse),\n/* harmony export */   HttpTransportType: () => (/* reexport safe */ _ITransport__WEBPACK_IMPORTED_MODULE_7__.HttpTransportType),\n/* harmony export */   HubConnection: () => (/* reexport safe */ _HubConnection__WEBPACK_IMPORTED_MODULE_3__.HubConnection),\n/* harmony export */   HubConnectionBuilder: () => (/* reexport safe */ _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__.HubConnectionBuilder),\n/* harmony export */   HubConnectionState: () => (/* reexport safe */ _HubConnection__WEBPACK_IMPORTED_MODULE_3__.HubConnectionState),\n/* harmony export */   JsonHubProtocol: () => (/* reexport safe */ _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__.JsonHubProtocol),\n/* harmony export */   LogLevel: () => (/* reexport safe */ _ILogger__WEBPACK_IMPORTED_MODULE_6__.LogLevel),\n/* harmony export */   MessageType: () => (/* reexport safe */ _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__.MessageType),\n/* harmony export */   NullLogger: () => (/* reexport safe */ _Loggers__WEBPACK_IMPORTED_MODULE_8__.NullLogger),\n/* harmony export */   Subject: () => (/* reexport safe */ _Subject__WEBPACK_IMPORTED_MODULE_10__.Subject),\n/* harmony export */   TimeoutError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.TimeoutError),\n/* harmony export */   TransferFormat: () => (/* reexport safe */ _ITransport__WEBPACK_IMPORTED_MODULE_7__.TransferFormat),\n/* harmony export */   VERSION: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_11__.VERSION)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@microsoft/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/HttpClient.js\");\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultHttpClient */ \"./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js\");\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HubConnection */ \"./node_modules/@microsoft/signalr/dist/esm/HubConnection.js\");\n/* harmony import */ var _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HubConnectionBuilder */ \"./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IHubProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@microsoft/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ITransport */ \"./node_modules/@microsoft/signalr/dist/esm/ITransport.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@microsoft/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JsonHubProtocol */ \"./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Subject */ \"./node_modules/@microsoft/signalr/dist/esm/Subject.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@microsoft/signalr/dist/esm/Utils.js\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/@microsoft/signalr/dist/esm/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./NotificationComponent/index.ts");
/******/ 	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = __webpack_exports__;
/******/ 	
/******/ })()
;
if (window.ComponentFramework && window.ComponentFramework.registerControl) {
	ComponentFramework.registerControl('my.NotificationNamespace.NotificationComponent', pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.NotificationComponent);
} else {
	var my = my || {};
	my.NotificationNamespace = my.NotificationNamespace || {};
	my.NotificationNamespace.NotificationComponent = pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.NotificationComponent;
	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = undefined;
}